import { APP_INITIALIZER, InjectionToken, Injector, NgModule, inject } from '@angular/core';
import { RouterModule, Routes, Router, Route } from '@angular/router'; // Added Router, Route

// Layouts
import { MainLayoutComponent } from './site/layout/main-layout/main-layout.component';
// (If you don't have a separate layout component for the main area yet,
//  you can create one. Alternatively, you could keep using AppComponent,
//  but a dedicated layout component is cleaner.)

// Components
import { DisabledComponent } from './site/disabled/disabled.component';
import { UserLoginComponent } from './site/user/user-login/user-login.component';
import { ForgotPasswordComponent } from './site/user/passwords/forgot-password/forgot-password.component';
import { ResetPasswordComponent } from './site/user/passwords/reset-password/reset-password.component';
import { UserRegisterComponent } from './site/user/user-register/user-register.component';
import { UserVerifyComponent } from './site/user/user-verify/user-verify.component';
import { HomeComponent } from './site/home/home/home.component';


// Guards
import { DisabledGuardService } from './core/guard/disabled-guard.service';
import { AuthGuard } from './core/guard/auth-guard.service'; // Import AuthGuard
import { RoleGuard } from './core/guard/role-guard.service'; // Import RoleGuard

// Plugin Loading
import { PluginLoaderService } from './core/services/plugin-loader.service';
import { pluginLoaders } from 'plugins:all'; // Generated by esbuild
import { PluginLoadErrorComponent } from './shared/plugins/plugin-load-error/plugin-load-error.component';

// Import PortalLayoutComponent as it's now standalone and used for plugin host route
import { PortalLayoutComponent } from './portal/layout/portal-layout/portal-layout.component';
import { AdminLayoutComponent } from './admin/layout/admin-layout/admin-layout.component';


// This function creates the child routes for plugins.
function generatePluginChildRoutes(injector: Injector): Routes {
  console.log('[AppRoutingModule] generatePluginChildRoutes called');
  const pluginService = injector.get(PluginLoaderService);
  const manifests = pluginService.getPluginManifests();
  console.log('[AppRoutingModule] Fetched manifests for child routes:', JSON.parse(JSON.stringify(manifests)));
  console.log('[AppRoutingModule] Available pluginLoaders from esbuild:', pluginLoaders);

  const mappedRoutes: (Route | null)[] = manifests.map(manifest => {
    console.log(`[AppRoutingModule] Processing manifest for: ${manifest.name}`);
    console.log(`[AppRoutingModule]   - angularModulePath: ${manifest.angularModulePath}`);

    if (!manifest.angularModulePath || manifest.angularModulePath.trim() === '') {
      console.error(`[AppRoutingModule] Plugin manifest for "${manifest.name}" is missing or has an empty 'angularModulePath'. Skipping route generation for this plugin.`);
      return null;
    }

    const pathParts = manifest.angularModulePath.split('/');
    if (pathParts.length === 0 || !pathParts[0]) {
        console.error(`[AppRoutingModule] Plugin manifest for "${manifest.name}" has an invalid 'angularModulePath' ("${manifest.angularModulePath}"). Could not determine plugin folder. Skipping.`);
        return null;
    }
    const pluginFolder = pathParts[0]; // Extracts the first segment (e.g., "profile")
    const pluginKey = `portal/${pluginFolder}/${pluginFolder}`;
    console.log(`[AppRoutingModule]   - Determined pluginFolder: "${pluginFolder}", Generated pluginKey: "${pluginKey}"`);

    const loader = (pluginLoaders as any)[pluginKey];

    if (!loader) {
      console.error(`[AppRoutingModule] Plugin manifest for "${manifest.name}" found, but NO corresponding module loader for key "${pluginKey}" was generated in pluginLoaders.`);
      console.log('[AppRoutingModule] Available keys in pluginLoaders:', Object.keys(pluginLoaders));
      return null;
    } else {
      console.log(`[AppRoutingModule]   - Loader FOUND for pluginKey: ${pluginKey}`);
    }

    const pathSegments = manifest.routePath.split('/');
    const finalRoutePath = pathSegments[pathSegments.length - 1];
    console.log(`[AppRoutingModule]   - Original manifest.routePath: ${manifest.routePath}, Derived routePath for routing: ${finalRoutePath}`);

    if (!finalRoutePath) {
      console.warn(`[AppRoutingModule]   - Plugin ${manifest.name} has an empty finalRoutePath, skipping.`);
      return null;
    }

    return {
      path: finalRoutePath, // e.g., 'sample'
      loadChildren: () => {
        console.log(`[AppRoutingModule] Executing loadChildren for plugin route: ${finalRoutePath}, pluginKey: ${pluginKey}`);
        return loader().then((m: any) => {
          console.log(`[AppRoutingModule] Module loaded for ${pluginKey}:`, m);

          if (!manifest.angularModuleName || manifest.angularModuleName.trim() === '') {
            console.error(`[AppRoutingModule] Plugin "${manifest.name}" (${pluginKey}) - 'angularModuleName' is missing or empty in its manifest. Cannot load module. Manifest details:`, manifest);
            return PluginLoadErrorComponent;
          }

          if (!m[manifest.angularModuleName]) {
            console.error(`[AppRoutingModule] Plugin "${manifest.name}" (${pluginKey}) - Module export "${manifest.angularModuleName}" not found in loaded module. Available exports:`, Object.keys(m));
            return PluginLoadErrorComponent;
          }
          return m[manifest.angularModuleName];
        }).catch((err: any) => {
          console.error(`[AppRoutingModule] Error loading module for ${pluginKey} (route: ${finalRoutePath}):`, err);
          // Instead of throwing, return the error component to be rendered by the router
          return PluginLoadErrorComponent;
        });
      },
      canActivate: [AuthGuard, RoleGuard], // Apply guards here
      data: {
        navigationLabel: manifest.navigationLabel,
        requiredRole: manifest.requiredRole,
        plugin: true
      }
    };
  });

  const finalPluginChildRoutes = mappedRoutes.filter((r): r is Route => r !== null);
  console.log('[AppRoutingModule] Final generated plugin child routes:', JSON.parse(JSON.stringify(finalPluginChildRoutes, (key, value) =>
    typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
  )));
  return finalPluginChildRoutes;
}

function generateAdminPluginChildRoutes(injector: Injector): Routes {
  console.log('[AppRoutingModule] generateAdminPluginChildRoutes called');
  const pluginService = injector.get(PluginLoaderService);
  const manifests = pluginService.getPluginManifests();
  console.log('[AppRoutingModule] Fetched manifests for admin child routes:', JSON.parse(JSON.stringify(manifests)));
  console.log('[AppRoutingModule] Available pluginLoaders from esbuild:', pluginLoaders);

  const mappedRoutes: (Route | null)[] = manifests.map(manifest => {
    if (!manifest.adminAngularModulePath || !manifest.adminRoutePath || !manifest.adminAngularModuleName) {
      return null;
    }
    console.log(`[AppRoutingModule] Processing admin manifest for: ${manifest.name}`);
    console.log(`[AppRoutingModule]   - adminAngularModulePath: ${manifest.adminAngularModulePath}`);

    if (!manifest.adminAngularModulePath || manifest.adminAngularModulePath.trim() === '') {
      console.error(`[AppRoutingModule] Admin plugin manifest for "${manifest.name}" is missing or has an empty 'adminAngularModulePath'. Skipping.`);
      return null;
    }

    // manifest.adminAngularModulePath is like "admin/profile-admin/profile-admin.module"
    // We need to get "profile-admin" from this for the pluginFolder.
    const relativePath = manifest.adminAngularModulePath.startsWith('admin/')
        ? manifest.adminAngularModulePath.substring('admin/'.length)
        : manifest.adminAngularModulePath; // Should ideally always start with 'admin/' based on esbuild logic a CJS

    if (relativePath.trim() === '') {
        console.error(`[AppRoutingModule] Admin plugin manifest for "${manifest.name}" has an 'adminAngularModulePath' ("${manifest.adminAngularModulePath}") that results in an empty relative path. Skipping.`);
        return null;
    }

    const pathParts = relativePath.split('/');
    if (pathParts.length === 0 || !pathParts[0]) {
        console.error(`[AppRoutingModule] Admin plugin manifest for "${manifest.name}" has an invalid 'adminAngularModulePath' ("${manifest.adminAngularModulePath}" -> "${relativePath}"). Could not determine plugin folder. Skipping.`);
        return null;
    }
    const pluginFolder = pathParts[0]; // Extracts "profile-admin"
    const pluginKey = `admin/${pluginFolder}/${pluginFolder}`;
    console.log(`[AppRoutingModule]   - Determined admin pluginFolder: "${pluginFolder}", Generated admin pluginKey: "${pluginKey}"`);

    const loader = (pluginLoaders as any)[pluginKey];

    if (!loader) {
      console.error(`[AppRoutingModule] Plugin manifest for "${manifest.name}" found, but NO corresponding module loader for key "${pluginKey}" was generated in pluginLoaders.`);
      console.log('[AppRoutingModule] Available keys in pluginLoaders:', Object.keys(pluginLoaders));
      return null;
    } else {
      console.log(`[AppRoutingModule]   - Loader FOUND for pluginKey: ${pluginKey}`);
    }

    const pathSegments = manifest.adminRoutePath.split('/');
    const finalRoutePath = pathSegments[pathSegments.length - 1];
    console.log(`[AppRoutingModule]   - Original manifest.adminRoutePath: ${manifest.adminRoutePath}, Derived routePath for routing: ${finalRoutePath}`);

    if (!finalRoutePath) {
      console.warn(`[AppRoutingModule]   - Plugin ${manifest.name} has an empty finalRoutePath, skipping.`);
      return null;
    }

    return {
      path: finalRoutePath, // e.g., 'sample-admin'
      loadChildren: () => {
        console.log(`[AppRoutingModule] Executing loadChildren for plugin route: ${finalRoutePath}, pluginKey: ${pluginKey}`);
        return loader().then((m: any) => {
          console.log(`[AppRoutingModule] Admin module loaded for ${pluginKey}:`, m);

          if (!manifest.adminAngularModuleName || manifest.adminAngularModuleName.trim() === '') {
            console.error(`[AppRoutingModule] Admin plugin "${manifest.name}" (${pluginKey}) - 'adminAngularModuleName' is missing or empty in its manifest. Cannot load module. Manifest details:`, manifest);
            return PluginLoadErrorComponent;
          }

          if (!m[manifest.adminAngularModuleName]) {
            console.error(`[AppRoutingModule] Admin plugin "${manifest.name}" (${pluginKey}) - Module export "${manifest.adminAngularModuleName}" not found in loaded admin module. Available exports:`, Object.keys(m));
            return PluginLoadErrorComponent;
          }
          return m[manifest.adminAngularModuleName];
        }).catch((err: any) => {
          console.error(`[AppRoutingModule] Error loading admin module for ${pluginKey} (route: ${finalRoutePath}):`, err);
          // Instead of throwing, return the error component to be rendered by the router
          return PluginLoadErrorComponent;
        });
      },
      canActivate: [AuthGuard, RoleGuard], // Apply guards here
      data: {
        navigationLabel: manifest.adminNavigationLabel,
        requiredRole: manifest.adminRequiredRole,
        plugin: true
      }
    };
  });

  const finalPluginChildRoutes = mappedRoutes.filter((r): r is Route => r !== null);
  console.log('[AppRoutingModule] Final generated admin plugin child routes:', JSON.parse(JSON.stringify(finalPluginChildRoutes, (key, value) =>
    typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
  )));
  return finalPluginChildRoutes;
}

// This function creates the host route for all plugins.
// We need to export it if used directly in APP_INITIALIZER factory signature, or keep it internal.
export function generatePluginHostRoutes(injector: Injector): Route[] {
  console.log('[AppRoutingModule] generatePluginHostRoutes called');
  const pluginChildRoutes = generatePluginChildRoutes(injector);

  if (pluginChildRoutes.length > 0) {
    const pluginHostRoute: Route = {
      path: 'portal', // This is the parent path for plugin routes
      component: PortalLayoutComponent, // Uses the standalone PortalLayoutComponent
      children: pluginChildRoutes // Dynamic plugin routes are children here
    };
    console.log('[AppRoutingModule] Generated plugin host route:', JSON.parse(JSON.stringify(pluginHostRoute, (key, value) =>
      typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
    )));
    return [pluginHostRoute]; // Return as an array of routes
  }
  console.log('[AppRoutingModule] No plugin child routes generated, so no plugin host route.');
  return []; // No plugins, no host route
}

export function generateAdminPluginHostRoutes(injector: Injector): Route[] {
  console.log('[AppRoutingModule] generateAdminPluginHostRoutes called');
  const pluginChildRoutes = generateAdminPluginChildRoutes(injector);

  if (pluginChildRoutes.length > 0) {
    const pluginHostRoute: Route = {
      path: 'admin', // This is the parent path for plugin routes
      component: AdminLayoutComponent,
      children: pluginChildRoutes // Dynamic plugin routes are children here
    };
    console.log('[AppRoutingModule] Generated admin plugin host route:', JSON.parse(JSON.stringify(pluginHostRoute, (key, value) =>
      typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
    )));
    return [pluginHostRoute]; // Return as an array of routes
  }
  console.log('[AppRoutingModule] No admin plugin child routes generated, so no admin plugin host route.');
  return []; // No plugins, no host route
}


const baseStaticRoutes: Routes = [ // Renamed to avoid confusion in APP_INITIALIZER
  // Main layout routes
  {
    path: '',
    component: MainLayoutComponent, // <-- your main layout for non-admin
    children: [
      { path: '', component: HomeComponent, canActivate: [DisabledGuardService] },
      { path: 'disabled', component: DisabledComponent }, 
      { path: 'login', component: UserLoginComponent, canActivate: [DisabledGuardService] },
      { path: 'forgot', component: ForgotPasswordComponent, canActivate: [DisabledGuardService] },
      { path: 'reset', component: ResetPasswordComponent, canActivate: [DisabledGuardService] },
      { path: 'register', component: UserRegisterComponent, canActivate: [DisabledGuardService] },
      { path: 'verify', component: UserVerifyComponent, canActivate: [DisabledGuardService] }
    ],
  },

  // Lazy-loaded Admin module
  // We'll show an example if you want to handle
  // the layout inside the AdminModule itself.
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    // If you prefer the AdminLayout at this level, you could do:
    // component: AdminLayoutComponent,
    // children: [ { path: '', loadChildren: ... } ]
  },
  {
    path: 'portal',
    // Ensure PortalModule is correctly located
    loadChildren: () => import('./portal/portal.module').then(m => m.PortalModule),
    // The children previously defined here statically (home, profile, etc.)
    // will now be loaded from PortalRoutingModule via PortalModule.
    // The APP_INITIALIZER will still find this 'portal' route by path
    // and add the dynamic plugin routes to its configuration.
    // The PortalLayoutComponent is expected to be defined as a root component
    // within portal-routing.module.ts for its routes.
  },

  // Wildcard / fallback
  { path: '**', redirectTo: '' },
];

@NgModule({
  imports: [RouterModule.forRoot([])], // Initialize with empty routes
  exports: [RouterModule],
  providers: [
    PluginLoaderService, // Ensure PluginLoaderService is available
    {
      provide: APP_INITIALIZER,
      useFactory: (pluginLoader: PluginLoaderService) => () => pluginLoader.loadPluginManifests(),
      deps: [PluginLoaderService],
      multi: true
    },
  // APP_INITIALIZER to configure routes dynamically
    {
      provide: APP_INITIALIZER,
    useFactory: (injector: Injector, pluginLoader: PluginLoaderService, router: Router) => { // Added Router here
        return async () => {
        console.log('[AppRoutingModule] APP_INITIALIZER for dynamic route configuration STARTING');

        // Ensure plugin manifests are loaded first
          if (pluginLoader.manifestLoadingPromise) {
            console.log('[AppRoutingModule] Waiting for manifestLoadingPromise to resolve...');
            await pluginLoader.manifestLoadingPromise;
            console.log('[AppRoutingModule] manifestLoadingPromise resolved.');
          } else {
          console.warn('[AppRoutingModule] manifestLoadingPromise not found on PluginLoaderService. Attempting to load them now.');
          await pluginLoader.loadPluginManifests(); // Fallback if not already initiated
          }

          console.log('[AppRoutingModule] Router instance:', router);

        // Generate the host route for plugins (e.g., { path: 'portal', component: PortalLayoutComponent, children: [...] })
        const pluginHostRoutes = generatePluginHostRoutes(injector);
        const adminPluginHostRoutes = generateAdminPluginHostRoutes(injector);
        console.log('[AppRoutingModule] Generated Plugin Host Routes:', JSON.parse(JSON.stringify(pluginHostRoutes, (key, value) =>
            typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
          )));

        // Construct the final routes array
        // Order: Plugin host routes first, then base static routes (which includes the lazy-loaded portal for static content)
        // This allows 'portal/plugin-path' to be matched by pluginHostRoutes,
        // and other 'portal/static-path' to be matched by the lazy-loaded PortalModule.
        const finalRoutes = [
          ...pluginHostRoutes, // Contains the { path: 'portal', component: PortalLayoutComponent, children: [plugin_routes...] }
          ...adminPluginHostRoutes,
          ...baseStaticRoutes   // Contains the { path: 'portal', loadChildren: ... } for static portal pages
        ];

        // Ensure wildcard is last if it exists, or add one.
        let wildcardRoute = finalRoutes.find(r => r.path === '**');
        if (wildcardRoute) {
          finalRoutes.splice(finalRoutes.indexOf(wildcardRoute), 1); // Remove from current position
        } else {
          wildcardRoute = { path: '**', redirectTo: '' }; // Create if not exists
        }
        finalRoutes.push(wildcardRoute); // Add to the end

        console.log('[AppRoutingModule] Final routes for resetConfig:', JSON.parse(JSON.stringify(finalRoutes, (key, value) =>
          typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
        )));

        router.resetConfig(finalRoutes);
        console.log('[AppRoutingModule] APP_INITIALIZER for dynamic route configuration COMPLETED');
        };
      },
    deps: [Injector, PluginLoaderService, Router], // Added Router to deps
      multi: true
    }
  ]
})
export class AppRoutingModule { }
