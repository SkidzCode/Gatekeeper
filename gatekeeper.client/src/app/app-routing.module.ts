import { APP_INITIALIZER, InjectionToken, Injector, NgModule, inject } from '@angular/core';
import { RouterModule, Routes, Router, Route } from '@angular/router'; // Added Router, Route

// Layouts
import { MainLayoutComponent } from './site/layout/main-layout/main-layout.component';
// (If you don't have a separate layout component for the main area yet,
//  you can create one. Alternatively, you could keep using AppComponent,
//  but a dedicated layout component is cleaner.)

// Components
import { DisabledComponent } from './site/disabled/disabled.component';
import { UserLoginComponent } from './site/user/user-login/user-login.component';
import { ForgotPasswordComponent } from './site/user/passwords/forgot-password/forgot-password.component';
import { ResetPasswordComponent } from './site/user/passwords/reset-password/reset-password.component';
import { UserRegisterComponent } from './site/user/user-register/user-register.component';
import { UserVerifyComponent } from './site/user/user-verify/user-verify.component';
import { HomeComponent } from './site/home/home/home.component';


// Guards
import { DisabledGuardService } from './core/guard/disabled-guard.service';

// Plugin Loading
import { PluginLoaderService } from './core/services/plugin-loader.service';
import { pluginLoaders } from 'plugins:all'; // Generated by esbuild
import { PortalLayoutComponent } from './portal/layout/portal-layout/portal-layout.component';


// This function creates the routes by combining backend data and frontend loaders
// We need to export it to be used in the AOT factory
export function generatePluginRoutes(injector: Injector): Routes {
  console.log('[AppRoutingModule] generatePluginRoutes called');
  const pluginService = injector.get(PluginLoaderService);
  const manifests = pluginService.getPluginManifests();
  console.log('[AppRoutingModule] Fetched manifests:', JSON.parse(JSON.stringify(manifests)));
  console.log('[AppRoutingModule] Available pluginLoaders from esbuild:', pluginLoaders);


  const mappedRoutes: (Route | null)[] = manifests.map(manifest => {
    console.log(`[AppRoutingModule] Processing manifest for: ${manifest.name}`);
    console.log(`[AppRoutingModule]   - angularModulePath: ${manifest.angularModulePath}`);
    const pluginKey = manifest.angularModulePath.replace(/\.module$/, ''); // Expected: 'plugins/sample/sample'
    console.log(`[AppRoutingModule]   - Generated pluginKey: ${pluginKey}`);

    const loader = (pluginLoaders as any)[pluginKey];

    if (!loader) {
      console.error(`[AppRoutingModule] Plugin manifest for "${manifest.name}" found, but NO corresponding module loader for key "${pluginKey}" was generated in pluginLoaders.`);
      console.log('[AppRoutingModule] Available keys in pluginLoaders:', Object.keys(pluginLoaders));
      return null;
    } else {
      console.log(`[AppRoutingModule]   - Loader FOUND for pluginKey: ${pluginKey}`);
    }

    // Ensure defaultRoutePath is correctly segmented
    // If manifest.defaultRoutePath is "portal/sample", we only want "sample"
    const pathSegments = manifest.defaultRoutePath.split('/');
    const routePath = pathSegments[pathSegments.length - 1];
    console.log(`[AppRoutingModule]   - Original manifest.defaultRoutePath: ${manifest.defaultRoutePath}, Derived routePath for routing: ${routePath}`);

    const routeConfig = {
      path: routePath, // e.g., 'sample'
      loadChildren: () => {
        console.log(`[AppRoutingModule] Executing loadChildren for route: ${routePath}, pluginKey: ${pluginKey}`);
        return loader().then((m: any) => {
          console.log(`[AppRoutingModule] Module loaded for ${pluginKey}:`, m);
          if (!m[manifest.angularModuleName]) {
            console.error(`[AppRoutingModule] Module ${manifest.angularModuleName} not found in loaded module for ${pluginKey}. Available exports:`, Object.keys(m));
          }
          return m[manifest.angularModuleName];
        }).catch((err: any) => {
          console.error(`[AppRoutingModule] Error loading module for ${pluginKey} (route: ${routePath}):`, err);
          throw err; // Re-throw to see it in console further if not caught by router
        });
      },
      data: {
        navigationLabel: manifest.navigationLabel,
        requiredRole: manifest.requiredRole,
        plugin: true // Mark as a plugin route
      }
    };
    return routeConfig; // Ensure routeConfig is returned
  });

  const finalPluginRoutes = mappedRoutes.filter((r): r is Route => r !== null);
  console.log('[AppRoutingModule] Final generated plugin routes:', JSON.parse(JSON.stringify(finalPluginRoutes, (key, value) =>
    typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
  )));
  return finalPluginRoutes;
}

// DYNAMIC_PLUGIN_ROUTES token can be removed if routes are generated directly in APP_INITIALIZER
// export const DYNAMIC_PLUGIN_ROUTES = new InjectionToken<Routes>('DYNAMIC_PLUGIN_ROUTES', {
//   providedIn: 'root',
//   factory: () => {
//     console.log('[AppRoutingModule] DYNAMIC_PLUGIN_ROUTES factory called.');
//     return generatePluginRoutes(inject(Injector));
//   }
// });

const staticRoutes: Routes = [
  // Main layout routes
  {
    path: '',
    component: MainLayoutComponent, // <-- your main layout for non-admin
    children: [
      { path: '', component: HomeComponent, canActivate: [DisabledGuardService] },
      { path: 'disabled', component: DisabledComponent }, 
      { path: 'login', component: UserLoginComponent, canActivate: [DisabledGuardService] },
      { path: 'forgot', component: ForgotPasswordComponent, canActivate: [DisabledGuardService] },
      { path: 'reset', component: ResetPasswordComponent, canActivate: [DisabledGuardService] },
      { path: 'register', component: UserRegisterComponent, canActivate: [DisabledGuardService] },
      { path: 'verify', component: UserVerifyComponent, canActivate: [DisabledGuardService] }
    ],
  },

  // Lazy-loaded Admin module
  // We'll show an example if you want to handle
  // the layout inside the AdminModule itself.
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    // If you prefer the AdminLayout at this level, you could do:
    // component: AdminLayoutComponent,
    // children: [ { path: '', loadChildren: ... } ]
  },
  {
    path: 'portal',
    component: PortalLayoutComponent, // Use the PortalLayoutComponent
    children: [
      // Static portal routes can go here, e.g.:
      // { path: 'dashboard', component: PortalDashboardComponent },

      // Dynamic plugin routes will be injected here by the factory
    ]
  },

  // Wildcard / fallback
  { path: '**', redirectTo: '' },
];

@NgModule({
  imports: [RouterModule.forRoot([])], // Initialize with empty routes
  exports: [RouterModule],
  providers: [
    PluginLoaderService, // Ensure PluginLoaderService is available
    {
      provide: APP_INITIALIZER,
      useFactory: (pluginLoader: PluginLoaderService) => () => pluginLoader.loadPluginManifests(),
      deps: [PluginLoaderService],
      multi: true
    },
    // DYNAMIC_PLUGIN_ROUTES token and its provider are removed.
    // Routes are generated and router is configured in the APP_INITIALIZER below.
    {
      provide: APP_INITIALIZER,
      useFactory: (injector: Injector, pluginLoader: PluginLoaderService) => {
        return async () => {
          console.log('[AppRoutingModule] APP_INITIALIZER for router reconfiguration STARTING');

          if (pluginLoader.manifestLoadingPromise) {
            console.log('[AppRoutingModule] Waiting for manifestLoadingPromise to resolve...');
            await pluginLoader.manifestLoadingPromise;
            console.log('[AppRoutingModule] manifestLoadingPromise resolved.');
          } else {
            // This case should ideally not happen if the other APP_INITIALIZER for loading manifests is set up correctly
            // and if PluginLoaderService is a true singleton.
            console.warn('[AppRoutingModule] manifestLoadingPromise not found on PluginLoaderService. This might indicate an issue with service instantiation order or APP_INITIALIZER setup.');
            // As a fallback, or if loadPluginManifests() was NOT part of another APP_INITIALIZER:
            // await pluginLoader.loadPluginManifests();
          }

          const router = injector.get(Router);
          console.log('[AppRoutingModule] Router instance:', router);

          const dynamicRoutes = generatePluginRoutes(injector);
          console.log('[AppRoutingModule] Dynamic routes generated:', JSON.parse(JSON.stringify(dynamicRoutes, (key, value) =>
            typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
          )));

        console.log('[AppRoutingModule] Static routes BEFORE modification:', JSON.parse(JSON.stringify(staticRoutes)));

        const portalRoute = staticRoutes.find(r => r.path === 'portal');
        if (portalRoute) {
          console.log('[AppRoutingModule] Found portal route:', JSON.parse(JSON.stringify(portalRoute)));
          if (!portalRoute.children) {
            portalRoute.children = [];
          }
          portalRoute.children.push(...dynamicRoutes);
          console.log('[AppRoutingModule] Portal route AFTER adding dynamic children:', JSON.parse(JSON.stringify(portalRoute, (key, value) =>
            typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
          )));
        } else {
          console.error("[AppRoutingModule] CRITICAL: Could not find '/portal' route to attach plugin routes.");
        }

        console.log('[AppRoutingModule] Final routes for resetConfig:', JSON.parse(JSON.stringify(staticRoutes, (key, value) =>
          typeof value === 'function' ? `FUNCTION: ${value.name || 'anonymous'}` : value
        )));
        router.resetConfig(staticRoutes);
        console.log('[AppRoutingModule] APP_INITIALIZER for router reconfiguration COMPLETED');
        };
      },
      deps: [Injector, PluginLoaderService],
      multi: true
    }
  ]
})
export class AppRoutingModule { }
