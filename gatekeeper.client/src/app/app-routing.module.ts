import { APP_INITIALIZER, InjectionToken, Injector, NgModule, inject } from '@angular/core';
import { RouterModule, Routes, Router, Route } from '@angular/router'; // Added Router, Route

// Layouts
import { MainLayoutComponent } from './site/layout/main-layout/main-layout.component';
// (If you don't have a separate layout component for the main area yet,
//  you can create one. Alternatively, you could keep using AppComponent,
//  but a dedicated layout component is cleaner.)

// Components
import { DisabledComponent } from './site/disabled/disabled.component';
import { UserLoginComponent } from './site/user/user-login/user-login.component';
import { ForgotPasswordComponent } from './site/user/passwords/forgot-password/forgot-password.component';
import { ResetPasswordComponent } from './site/user/passwords/reset-password/reset-password.component';
import { UserRegisterComponent } from './site/user/user-register/user-register.component';
import { UserVerifyComponent } from './site/user/user-verify/user-verify.component';
import { HomeComponent } from './site/home/home/home.component';


// Guards
import { DisabledGuardService } from './core/guard/disabled-guard.service';

// Plugin Loading
import { PluginLoaderService } from './core/services/plugin-loader.service';
import { pluginLoaders } from 'plugins:all'; // Generated by esbuild
import { PortalLayoutComponent } from './portal/layout/portal-layout/portal-layout.component';


// This function creates the routes by combining backend data and frontend loaders
// We need to export it to be used in the AOT factory
export function generatePluginRoutes(injector: Injector): Routes {
  const pluginService = injector.get(PluginLoaderService);
  const manifests = pluginService.getPluginManifests();

  const mappedRoutes: (Route | null)[] = manifests.map(manifest => {
    const pluginKey = manifest.angularModulePath.replace(/\.module$/, ''); // 'plugins/sample/sample'

    const loader = (pluginLoaders as any)[pluginKey];

    if (!loader) {
      console.error(`Plugin manifest for "${manifest.name}" found, but no corresponding module loader for key "${pluginKey}" was generated.`);
      return null;
    }

    // Ensure defaultRoutePath is correctly segmented
    // If manifest.defaultRoutePath is "portal/sample", we only want "sample"
    const pathSegments = manifest.defaultRoutePath.split('/');
    const routePath = pathSegments[pathSegments.length - 1];

    return {
      path: routePath, // e.g., 'sample'
      loadChildren: () => loader().then((m: any) => m[manifest.angularModuleName]),
      data: {
        navigationLabel: manifest.navigationLabel,
        requiredRole: manifest.requiredRole,
        plugin: true // Mark as a plugin route
      }
    };
  });

  return mappedRoutes.filter((r): r is Route => r !== null);
}

// Use an InjectionToken for the dynamically generated routes
export const DYNAMIC_PLUGIN_ROUTES = new InjectionToken<Routes>('DYNAMIC_PLUGIN_ROUTES', {
  providedIn: 'root',
  factory: () => generatePluginRoutes(inject(Injector)) // inject Injector
});

const staticRoutes: Routes = [
  // Main layout routes
  {
    path: '',
    component: MainLayoutComponent, // <-- your main layout for non-admin
    children: [
      { path: '', component: HomeComponent, canActivate: [DisabledGuardService] },
      { path: 'disabled', component: DisabledComponent }, 
      { path: 'login', component: UserLoginComponent, canActivate: [DisabledGuardService] },
      { path: 'forgot', component: ForgotPasswordComponent, canActivate: [DisabledGuardService] },
      { path: 'reset', component: ResetPasswordComponent, canActivate: [DisabledGuardService] },
      { path: 'register', component: UserRegisterComponent, canActivate: [DisabledGuardService] },
      { path: 'verify', component: UserVerifyComponent, canActivate: [DisabledGuardService] }
    ],
  },

  // Lazy-loaded Admin module
  // We'll show an example if you want to handle
  // the layout inside the AdminModule itself.
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    // If you prefer the AdminLayout at this level, you could do:
    // component: AdminLayoutComponent,
    // children: [ { path: '', loadChildren: ... } ]
  },
  {
    path: 'portal',
    component: PortalLayoutComponent, // Use the PortalLayoutComponent
    children: [
      // Static portal routes can go here, e.g.:
      // { path: 'dashboard', component: PortalDashboardComponent },

      // Dynamic plugin routes will be injected here by the factory
    ]
  },

  // Wildcard / fallback
  { path: '**', redirectTo: '' },
];

@NgModule({
  imports: [RouterModule.forRoot([])], // Initialize with empty routes
  exports: [RouterModule],
  providers: [
    PluginLoaderService, // Ensure PluginLoaderService is available
    {
      provide: APP_INITIALIZER,
      useFactory: (pluginLoader: PluginLoaderService) => () => pluginLoader.loadPluginManifests(),
      deps: [PluginLoaderService],
      multi: true
    },
    // DYNAMIC_PLUGIN_ROUTES is now providedIn: 'root'
    // {
    //   provide: DYNAMIC_PLUGIN_ROUTES,
    //   useFactory: generatePluginRoutes,
    //   deps: [Injector]
    // },
    {
      provide: APP_INITIALIZER, // Changed from NgModule to APP_INITIALIZER for router reconfiguration
      useFactory: (injector: Injector) => () => { // Return a function for APP_INITIALIZER
        const router = injector.get(Router); // Use imported Router
        const dynamicRoutes = injector.get(DYNAMIC_PLUGIN_ROUTES);

        // Find the '/portal' route and add children to it
        const portalRoute = staticRoutes.find(r => r.path === 'portal');
        if (portalRoute && portalRoute.children) {
          portalRoute.children.push(...dynamicRoutes);
        } else if (portalRoute) {
          portalRoute.children = dynamicRoutes;
        } else {
          console.error("Could not find '/portal' route to attach plugin routes.");
        }

        router.resetConfig(staticRoutes);
        // No return needed for APP_INITIALIZER factory that returns a function
      },
      deps: [Injector],
      multi: true
    }
  ]
})
export class AppRoutingModule { }
